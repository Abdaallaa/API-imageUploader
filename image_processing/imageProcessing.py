# -*- coding: utf-8 -*-
"""graduation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YQEdtfRZCXgPCYAU4QIAi81Km5Fs_M9o
"""
from skimage import feature , color , measure
from skimage.io import imread , imsave
from skimage.filters import unsharp_mask
import cv2
import numpy as np
# from google.colab.patches import cv2_imshow
def pos (a,orination):
  sk=[]
  an=-1
  sorte=[]
  order=(orination=='vl')
  if(orination[0]=='v'):
    for i in range(0,len(a)-1):
      if(a[i+1][1]+5<a[i][1]+a[i][3]):
        if(an==-1):
          an=i
          sk=sk+[a[i]]
        sk=sk+[a[i+1]]
      elif(an>-1):
        sk=sorted(sk, key=lambda box: (box[0]),reverse=order)
        sorte=sorte+sk
        sk=[]
        an=-1
      else:
        sorte=sorte+[a[i]]
    if(an>-1):
        sorte=sorte+sorted(sk, key=lambda box: (box[0]),reverse=order)
    else:
        sorte=sorte+[a[-1]]   
  return sorte
def rolo (a):
    las=[]
    x=0
    for i in range(1,len(a)):
        if(a[i]-a[i-1]>12):
            las=las+[sum(a[x:i])//(i-x)]
            x=i
    las=las+[sum(a[x:len(a)])//(len(a)-x)]
    print(las)
    re=[las[0]]
    avg=sum([las[i]-las[i-1] for i in range(1,len(las))])//(len(las)-1)
    print(avg)
    for i in range(1,len(las)):
      if(las[i]-re[-1]>avg-5):
        re=re+[las[i]]
    return re
def fntn (box):
    bou=box
    i=0
    while(i<len(bou)):
      j=i+1
      while(j<len(bou)):
        if(bou[j][0]>=bou[i][0] and bou[j][1]>=bou[i][1] and bou[j][0]+bou[j][2]<=(bou[i][0]+bou[i][2]) and bou[j][1]+bou[j][3]<=(bou[i][1]+bou[i][3])):
          bou.pop(j)
        else:
          j=j+1
      i=i+1
    return bou
def inter(box):
  bou=box
  i=0
  while(i<len(bou)):
    j=i+1
    while(j<len(bou)):
      if(((bou[j][0]<=bou[i][0] and (bou[j][0]+bou[j][2]>=bou[i][0]-1)) or (bou[i][0]<=bou[j][0] and bou[i][0]+bou[i][2]>=bou[j][0]-1) ) and bou[i][1]+bou[i][3]>=bou[j][1]+5 ):
        xn=min(bou[i][0],bou[j][0])
        wn=max(bou[i][0]+bou[i][2],bou[j][0]+bou[j][2])-xn
        yn=min(bou[i][1],bou[j][1])
        hn=max(bou[i][1]+bou[i][3],bou[j][1]+bou[j][3])-yn
        bou[i]=[xn,yn,wn,hn]
        bou.pop(j)
        if(i>0):i=i-1
        j=i+1
      elif(bou[j][1]+(bou[j][3]//2)>bou[i][1]+bou[i][3]):
        break
      else:
        j=j+1
    i=i+1
  return bou
#pre-process image
def imagePreProcess(imagePath):
  # 'fezo.jpg'
  ori=  cv2.imread(imagePath)
  fino= cv2.imread(imagePath)
  fina= cv2.imread(imagePath)
  img=imread(imagePath)
  img=color.rgb2gray(img)
  img=unsharp_mask(img, radius=20, amount=6)
  edg=feature.canny(img,sigma=2.5)
  edg=np.uint8(edg * 255)
  imsave('result.jpg',edg)
  lines = cv2.HoughLines(edg,1,np.pi/180,225)
  res=[]
  hor=[]
  for line in lines:
    rho,theta = line[0]
    a = np.cos(theta)
    b = np.sin(theta)
    x0 = a * rho
    y0 = b * rho
    x1 = int(x0 + 1000 * (-b))
    y1 = int(y0 + 1000 * (a))
    x2 = int(x0 - 1000 * (-b))
    y2 = int(y0 - 1000 * (a))
    if(theta==0):
      res=res+[x2]
      cv2.line(fino, (x1, y1), (x2, y2), (0, 0, 250), 2)
    if(theta-1<0.6 and theta>1 and y1>0):
      hor=hor+[y1]
      cv2.line(fino, (x1, y1), (x2, y2), (0, 0, 250), 2)
  cv2.imwrite('fin.jpg', fino)
  res.sort()
  res=rolo(res)
  print(res)
  for i in range(0,len(res)):
    b=np.sin(0)
    a=np.cos(0)
    x=res[i]
    y0 = b *x
    y1 = int(y0 + 1000 * (a))
    y2 = int(y0 - 1000 * (a))
    cv2.line(fina, (x, 0), (x , fina.shape[0]), (0, 0, 255), 2)
  cv2.imwrite('fia.jpg', fina)
  for i in range(0,len(res)-1):
    sec=ori[0:fina.shape[0],res[i]:res[i+1]]
    cv2.imwrite('sections/{}.jpg'.format(str(i)), sec)
    ow=res[i+1]
    # FIXME: 
    sli=cv2.imread('sections/{}.jpg'.format(str(i)))
    gj=cv2.imread('sections/{}.jpg'.format(str(i)))
    imgr = cv2.cvtColor(sli, cv2.COLOR_BGR2GRAY)
    imgr = cv2.GaussianBlur(imgr, (3, 3), 0)
    imgr=unsharp_mask(imgr, radius=3, amount=1)
    imgr = (255*imgr).astype(np.uint8)
    ret, thresh = cv2.threshold(imgr, 127, 255, 0)
    #thresh = cv2.erode(thresh, None, iterations=1)
    #thresh = cv2.dilate(thresh, None, iterations=1)
    cv2.imwrite('sections/thresh{}.jpg'.format(str(i)),thresh)
    img=color.rgb2gray(thresh)
    #edg=feature.canny(img,sigma=3)
    #edg=np.uint8(edg * 255)
    #cv2.imwrite('sections/edgo{}.jpg'.format(str(i)),edg)
    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    boxes=[]
    for cnt in contours:
      x,y,w,h=cv2.boundingRect(cnt)
      if(w<80 and h<500 and x<ow-10):boxes=boxes+[[x,y,w,h]]
      cv2.rectangle(sli, (x, y), (x + w, y + h), (0,255,0), 2)
    cv2.imwrite('sections/final{}.jpg'.format(str(i)),sli)
    boxes=sorted(boxes, key=lambda box: (box[2]*box[3]),reverse=True)
    boxes=fntn(boxes)
    boxes=sorted(boxes, key=lambda box: (box[1]))
    boxes=inter(boxes)
    boxes=[box for box in boxes if(box[2]*box[3]>190)]
    boxes=pos(boxes,'vl')
    for  box in boxes:
      x,y,w,h=box
      cv2.rectangle(gj, (x, y), (x + w, y+h), (0,255,0), 1)
    # cv2.imwrite('sections/show{}.jpg'.format(str(i)),gj)
